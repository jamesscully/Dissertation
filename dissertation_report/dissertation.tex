\documentclass[11pt]{article}
\usepackage{outlines}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{subcaption}
\usepackage[margin=1in]{geometry}

\usepackage{geometry}
\usepackage[square,sort,comma,numbers,super]{natbib}
\usepackage{pdflscape}
\usepackage[colorlinks,allcolors=blue]{hyperref}
\usepackage{afterpage}

\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\definecolor{textblue}{rgb}{.2,.2,.7}
\definecolor{textred}{rgb}{0.54,0,0}
\definecolor{textgreen}{rgb}{0,0.43,0}

\usepackage{enumitem}
\usepackage{listings}
\usepackage[export]{adjustbox}
\usepackage{wrapfig}
\usepackage[ruled,vlined]{algorithm2e}

\usepackage{tocloft}
\setlength{\cftbeforesecskip}{2pt}

\setlist{nosep}

\lstset{language=Java, 
lineskip=-.1cm,
stepnumber=1,
numbersep=2pt, 
tabsize=4,
basicstyle=\ttfamily,
keywordstyle=\color{textblue},
commentstyle=\color{textred},   
stringstyle=\color{textgreen},
frame=none,                    
columns=fullflexible,
keepspaces=true,
xleftmargin=\parindent,
showstringspaces=false}

\graphicspath{ {./images/} }

\setlength{\parindent}{0pt}

% pt = project title; shorthand
\newcommand{\pt}{Multi-User Poker Game}
\newcommand{\pn}{Rekop}

\title{Dissertation \pt}
\author{James Scully}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{5}



\begin{document}

{\fontfamily{cmss}\selectfont}



\newcommand{\cardheight}{6em}

\newcommand{\tenclubs}{\includegraphics[height=\cardheight]{cards/10_of_clubs.png}}
\newcommand{\tendiamonds}{\includegraphics[height=\cardheight]{cards/10_of_diamonds.png}}
\newcommand{\tenhearts}{\includegraphics[height=\cardheight]{cards/10_of_hearts.png}}
\newcommand{\tenspades}{\includegraphics[height=\cardheight]{cards/10_of_spades.png}}
\newcommand{\twoclubs}{\includegraphics[height=\cardheight]{cards/2_of_clubs.png}}
\newcommand{\twodiamonds}{\includegraphics[height=\cardheight]{cards/2_of_diamonds.png}}
\newcommand{\twohearts}{\includegraphics[height=\cardheight]{cards/2_of_hearts.png}}
\newcommand{\twospades}{\includegraphics[height=\cardheight]{cards/2_of_spades.png}}
\newcommand{\threeclubs}{\includegraphics[height=\cardheight]{cards/3_of_clubs.png}}
\newcommand{\threediamonds}{\includegraphics[height=\cardheight]{cards/3_of_diamonds.png}}
\newcommand{\threehearts}{\includegraphics[height=\cardheight]{cards/3_of_hearts.png}}
\newcommand{\threespades}{\includegraphics[height=\cardheight]{cards/3_of_spades.png}}
\newcommand{\fourclubs}{\includegraphics[height=\cardheight]{cards/4_of_clubs.png}}
\newcommand{\fourdiamonds}{\includegraphics[height=\cardheight]{cards/4_of_diamonds.png}}
\newcommand{\fourhearts}{\includegraphics[height=\cardheight]{cards/4_of_hearts.png}}
\newcommand{\fourspades}{\includegraphics[height=\cardheight]{cards/4_of_spades.png}}
\newcommand{\fiveclubs}{\includegraphics[height=\cardheight]{cards/5_of_clubs.png}}
\newcommand{\fivediamonds}{\includegraphics[height=\cardheight]{cards/5_of_diamonds.png}}
\newcommand{\fivehearts}{\includegraphics[height=\cardheight]{cards/5_of_hearts.png}}
\newcommand{\fivespades}{\includegraphics[height=\cardheight]{cards/5_of_spades.png}}
\newcommand{\sixclubs}{\includegraphics[height=\cardheight]{cards/6_of_clubs.png}}
\newcommand{\sixdiamonds}{\includegraphics[height=\cardheight]{cards/6_of_diamonds.png}}
\newcommand{\sixhearts}{\includegraphics[height=\cardheight]{cards/6_of_hearts.png}}
\newcommand{\sixspades}{\includegraphics[height=\cardheight]{cards/6_of_spades.png}}
\newcommand{\sevenclubs}{\includegraphics[height=\cardheight]{cards/7_of_clubs.png}}
\newcommand{\sevendiamonds}{\includegraphics[height=\cardheight]{cards/7_of_diamonds.png}}
\newcommand{\sevenhearts}{\includegraphics[height=\cardheight]{cards/7_of_hearts.png}}
\newcommand{\sevenspades}{\includegraphics[height=\cardheight]{cards/7_of_spades.png}}
\newcommand{\eightclubs}{\includegraphics[height=\cardheight]{cards/8_of_clubs.png}}
\newcommand{\eightdiamonds}{\includegraphics[height=\cardheight]{cards/8_of_diamonds.png}}
\newcommand{\eighthearts}{\includegraphics[height=\cardheight]{cards/8_of_hearts.png}}
\newcommand{\eightspades}{\includegraphics[height=\cardheight]{cards/8_of_spades.png}}
\newcommand{\nineclubs}{\includegraphics[height=\cardheight]{cards/9_of_clubs.png}}
\newcommand{\ninediamonds}{\includegraphics[height=\cardheight]{cards/9_of_diamonds.png}}
\newcommand{\ninehearts}{\includegraphics[height=\cardheight]{cards/9_of_hearts.png}}
\newcommand{\ninespades}{\includegraphics[height=\cardheight]{cards/9_of_spades.png}}
\newcommand{\aceclubs}{\includegraphics[height=\cardheight]{cards/ace_of_clubs.png}}
\newcommand{\acediamonds}{\includegraphics[height=\cardheight]{cards/ace_of_diamonds.png}}
\newcommand{\acehearts}{\includegraphics[height=\cardheight]{cards/ace_of_hearts.png}}
\newcommand{\acespades}{\includegraphics[height=\cardheight]{cards/ace_of_spades.png}}
\newcommand{\jackclubs}{\includegraphics[height=\cardheight]{cards/jack_of_clubs.png}}
\newcommand{\jackdiamonds}{\includegraphics[height=\cardheight]{cards/jack_of_diamonds.png}}
\newcommand{\jackhearts}{\includegraphics[height=\cardheight]{cards/jack_of_hearts.png}}
\newcommand{\jackspades}{\includegraphics[height=\cardheight]{cards/jack_of_spades.png}}
\newcommand{\kingclubs}{\includegraphics[height=\cardheight]{cards/king_of_clubs.png}}
\newcommand{\kingdiamonds}{\includegraphics[height=\cardheight]{cards/king_of_diamonds.png}}
\newcommand{\kinghearts}{\includegraphics[height=\cardheight]{cards/king_of_hearts.png}}
\newcommand{\kingspades}{\includegraphics[height=\cardheight]{cards/king_of_spades.png}}
\newcommand{\queenclubs}{\includegraphics[height=\cardheight]{cards/queen_of_clubs.png}}
\newcommand{\queendiamonds}{\includegraphics[height=\cardheight]{cards/queen_of_diamonds.png}}
\newcommand{\queenhearts}{\includegraphics[height=\cardheight]{cards/queen_of_hearts.png}}
\newcommand{\queenspades}{\includegraphics[height=\cardheight]{cards/queen_of_spades.png}}

\hspace{0pt}

\vfill

\begin{center}
	\includegraphics[scale=0.4]{uni_logo}
	
	\vspace{1cm}
	
	{\Large \textbf{Dissertation\\} 
		\vspace{16pt}
		Multi-User Interactive Delay-Tolerant Network\\
		\vspace{16pt}
		\textit{Rekop Poker}} 		
		\linebreak
		
	\textbf{I hereby declare that this dissertation is all my own work, \\except as indicated in the text} \\
	\vspace{8pt}
	\textbf{Signature}: J. W. Scully \\
	\textbf{Date}: 4/5/2020 \linebreak
		
	\begin{large}
		James Scully (14304469) \\
		psyjs20@nottingham.ac.uk \\
		G400 Computer Science \linebreak \\ 
	\end{large}
	
\end{center}

\vfill

\begin{center}
	\textbf{Project Supervisor:} Milena Radenkovic
\end{center}

\hspace{0pt}

\pagebreak


\newcommand{\entry}[1]{
	\textbf{#1} - 
}

\newcommand{\TODO}[1]{
	\textbf{{\Large \emph{#1}}}
}



\tableofcontents



\newpage


%%%
% Page 1: 
%%%

% \hyperlink{research_texas}{(A Gilpin, 2006)}
% \hyperlink{wsop_texas}{(WSOP, 2019)}

\section{Introduction}
Poker is a type of card game that is played and watched in tournaments by many around the world. Because of it's wide popularity, it has spawned multiple types, the most popular one being Texas Hold'em, which is the main type used in both research \cite{research_texas} and is the main variant used in the World Series of Poker \cite{wsop_texas}. Other types include the similar yet lesser-known Omaha hold'em and Five-card draw; a simpler type of poker, which does not utilize the typical table seen in both hold'ems. \\

A common problem encountered with most networks is that the client or user of a service can have a weak or 'spotty' internet connection, whereby they may lose connectivity occasionally or in certain bursts. This is especially prevalent with mobile connections, where rural or otherwise distanced areas can have trouble holding a steady connection. In these cases, it is vital that both the client is able to use the network or join as normal and that the server does not grind to a halt waiting on this person or break due to it, known as a \textit{delay-tolerant network} (DTN). \\

Delay-tolerant networks have been especially important in the modern world since the advent of mobile phones and their surge in popularity, such as the potential to use them to route packets for DTNs \cite{manet}. This is due to the fact that they do not have a regular stable internet connection like most desktop computers do and have the problem of losing signal due to physical movement or placement of the device. If a network cannot handle delay or dropouts from a mobile client gracefully this can have devastating impacts on data integrity or the overall function of the service. \\

Figure 1 shows how the rotation of play in poker occurs. If the player with an unstable connection is unable to respond and the server is not able to proceed, then the match cannot occur as normal. Other players will not be able to take their turns, and the lost player upon reconnection may not be able to see choices taken or their chips.

\noindent
	\begin{figure}[h]
\makebox[\textwidth]{	\includegraphics[height=20em]{connectivity_play}	}%
\caption{When not handled properly, the service can be halted}
	\end{figure} 

\newpage
Though the term mobile devices can imply the use of mobile phones, mobile devices can range from not only a handheld phone but to vehicles, robotics, aeroplanes and satellites \citep{goth_ieee}. Whilst data integrity to a mobile phone may not be incredibly important, data integrity is certainly incredibly important to an aeroplane or satellite, where a small error or wrong instruction can result in major failure. \\

The service must be able to realise that a device is either experiencing delay/dropouts and must respond accordingly; either by aiming to keep future data consistent with the previously sent data, or by accounting for the delay. In our case, we aim to send data stored on the server to each client in order to keep them up to date with the game. \\

This data 'overwrites' the clients data: we send packets to them that describe the exact state of the game at the current time. Figure 2 shows the difference between sending overwriting packets, or sending incremental, normal packets upon the end of the round. \\

2(a) shows when a player reconnects, they are sent the state of the game such that they know what has occurred whilst disconnected and allow them to plan ahead; 2(b) does not give any state on the game, any new packets sent would only reveal the cards not in view to anyone, and they would not see others or their own chip count. This approach was inspired by the store-and-forward approach that DTNs require \cite{ieee_storefwd}, so that any lost or missed data is able to be reclaimed.\\

\vspace{40pt}

\begin{figure}[h]
	\makebox[\textwidth][c]{
	\begin{subfigure}[h]{0.625\textwidth}
		\includegraphics[width=\textwidth]{store_forward}
		\caption{Overwriting packets of data}
	\end{subfigure}	
	
	\begin{subfigure}[h]{0.625\textwidth}
		\includegraphics[width=\textwidth]{no_store_forward}
		\caption{No 'overwriting' packets of data}
	\end{subfigure}	
	}
	
	\caption{Disconnected player joining back during the game, after the flop}
	
\end{figure}




%When one looks for a casual poker game that offers power to the actual end user, rather than attempting to fish money it can be quite difficult to find. From the authors own personal experience and observations with free and open software, it can be quite difficult to implement in some areas (such as games), however the ability to control a game how you would like and the ability to not have to rely on companies servers, trudge through in-application payments and ads is a unseen experience today. Some also do not allow for players with unreliable connections to continue; they are simply dropped from the game.  \\

%I believe that many of these are far too focused on the financial aspect of the game and neglect the small groups whom simply would like another medium to play poker. This is because lobbies are often not customizable and will drop players whom do not have a good enough network connection to the lobby, so that more players are able to join.  \\

%To remedy these issues, Rekop poker will be developed to handle disconnections or unstable connections by reserving their place in the lobby and the ability to join back when the player is available to. It will also not feature micro-transactions and provide the ability for players to host their own servers, with their own settings.
\newpage
\subsection{Motivation}

Rekop poker aims to provide an open-sourced framework for the popular variant of poker, Texas Hold'em. Many existing games of poker often include micro transactions and no ability to customize the gamemode, host their own servers or modify the source code to implement other gamemodes or wanted features. Moreover, the game of poker can be used as a great vessel - especially considering mobile networks - to learn more about delay-tolerant networks, as this is becoming the most important feature of any given service on the internet as mobile devices rise in popularity. 

\section{Methodology}

\subsection{Test-Driven Development}

Test-Driven Development (TDD) drove the development of the poker evaluation algorithm as we can easily check what the highest suit of a hand is manually, such as if it is a straight or a flush. When developing these small functions, we could easily write test cases ahead of actual programming and then run them with each change. This had the added benefit of being able to easily write edge cases for each function to make sure that it was rigorous and we were not experiencing "bias" or writing tests to fit the current code when testing.  \\

For example, the isStraight function at one point had a small case where a straight only needed 4 cards to be ascending/descending. \\

\begin{figure}[h]
	\makebox[\textwidth][c]{
	\begin{subfigure}[h]{0.49\textwidth}
		\fiveclubs \sixclubs \sevenhearts\eightclubs\ninediamonds
		\caption{A typical straight, 5 to 9 sequentially}
	\end{subfigure}	
	
	\begin{subfigure}[h]{0.49\textwidth}
		\fiveclubs \sixclubs \sevenhearts\eightclubs\eightclubs
		\caption{Edge case found, duplicate 8's counted}
	\end{subfigure}	
	}
	\caption{A valid straight versus the edge case we detected through unit testing}
\end{figure}

Had we not taken a test-heavy approach, given that a straight itself is quite uncommon \cite{str_uncommon}, at around 0.392465\% this could have been undetected for quite some time. \\

However, a benefit of this that was only realised afterwards was that writing unit-testable code made the actual code-base much more modular. This has lead to the actual evaluator in turn becoming much higher quality code, as there is much less overlap between each function when determining the outcome of a hand.  \hyperlink{app_eval}{Appendix 8.2} shows this, as we can see that we only have functions to call rather than intertwining them. 

% Kent Beck, an early proponent of TDD methodology and creator of JUnit, clarifies this by 

\newpage
\subsection{Agile}

Agile is a relatively new methodology that can be described as very iterative, with a low design overhead. Its principles hold a focus on the self-sustenance of developers, rapid and continuous delivery of working software and continuous communication between each team member, as declared by it's manifesto \cite{agile_principles}. It has been reported that the more the methodology is applied to a project, the more likely a project is to be considered successful. \cite{agile_success} \\ %\hyperlink{agile_success}{(P Serrador, 2015)}.  \\

Whilst this was a one man project, the principles and ideas behind the Agile methodology have not been forgotten. This is primarily because of how well the rapid development cycle coincides with TDD; we were able to get instantaneous feedback and improve upon it. This especially occured in the backend of the project, whereby we could push better quality code and constantly improve with a concrete set of tests. \\

We were accepting to new requirements as it was realised that the initial idea of a grandiose mobile application may be a bit too much to handle within the given timeframe; we instead decided to move towards developing the core idea of the project: exploring creating a delay tolerant network. \\

When it came to developing the server and client connection, we realised that making an incredibly detailed design on a concept that was not particularly familiar with the author would more than likely end up in time wasted. Therefore, we decided to iteratively work on getting certain milestones completed: basic connection, starting with small ping messages. Next, we would work on implementing sending a single card between the client/server, then we would work on getting a hand of cards over. \\

% Whilst we were sure to run into some errors this way, the usage of TDD methods enabled us to get past this; namely using a logger to show what the client/server was performing or looking for.

% Agile has also been the driving development cycle - primarily creating a very basic yet functional version of the software and accepting of changing requirements. For example, the back-end was created first so that the game mode itself was in an acceptable state. From here, it made it easier to visualize how the server would handle sending, receiving and processing the player's cards. \\

%Though this helps develop a certain sector and thus the entire project succeed, as observed by the link of Agile/iterative incentive to success in \hyperlink{agile_success}{(P Serrador, 2015)}, it can lead to over-development of one area and cause tunnel-vision, as was the case with not developing both the poker back-end and the server software at-least somewhat concurrently. For a time-constrained project like this, it is best to find a middle-ground. 


%(?)

\newpage
\section{Design}

\subsection{Overview}

The project itself is broken down into two components, the back-end, which is the processing of poker hands and the representation of poker data classes, and the other component being the server, which is responsible for handling incoming connections and disconnections gracefully.  \\

% \cite{ieee_storefwd} https://tools.ietf.org/html/rfc4838#page-5
We decided to make the server handle most of the operations performed, with the client being responsible for sending their intentions (call, fold, raise) and receiving data about the current cards on the table. This is part of ensuring the network holds a form of 'store-and-forward', whereby data can be packaged and sent to a reconnecting client \cite{ieee_storefwd}. \\

This can be seen in Figure 4, where the user is asked for their intention when it is their turn, and sent back. On the beginning of each round, we send the current table data to the players regardless of if they have folded or not; such that when a player is to reconnect, they are able to see the cards in play and actions taken, as well as their current chips.

\noindent
	\begin{figure}[h]
\makebox[\textwidth]{	\includegraphics[width=\paperwidth]{server_client_seq}	}%
\caption{Communication between client and servers components}
	\end{figure} 
	
\newpage
\subsection{Backend}

The backend - that is, the Texas Hold'em evaluator and other objects - is written solely in Java as the language itself is platform agnostic, which allows for the server to run on Linux, Windows and Mac, as per the requirements defined in the initial vision and scope document. This makes the client and server portable as the running platform needs only a Java 8 compatible virtual machine.  \\

We considered other languages such as C/C++, which would be magnitudes faster in performance however they are not easily portable to multiple platforms, which is part of our project requirements. For example, compilation issues can arise from using different compilers. Similarly, using a web-based language and framework such as JavaScript or PHP with libraries such as React/Angular would not fit into the system design; we need to host a server, and link the backend into it. \\
%(?) magnitudes faster


It has been broken down in such a way that it is modular, by having the basics common to all other types of poker involved, such as cards, ranks, values and suits, aswell as a 52-card deck with the ability to pull a guaranteed random, unique card regardless of where the code is executed (via a singleton pattern). \\

	\begin{figure}[h]
\makebox[\textwidth]{	\includegraphics[width=0.75\textwidth]{classdiagram}	}%
\caption{Class diagram of the base card objects}
	\end{figure} 

These objects can be re-used for other gamemodes as part of our vision for the project. If a developer in the future wishes to add another gamemode, such as Ohama Hold'em or Five Card Draw, they would need to create an evaluator for that gamemode and alter the \textit{processRound()} and \textit{dealRound()} functions in the server.


\newpage
\subsection{Networking}
\subsubsection{Introduction}
The networking is based upon client-server architecture using a Thread-pool written in Java. Initially, we wished to use a Peer-to-Peer / Universal Plug-n-Play (UPnP) approach, however delay/disconnection-tolerance, whilst possible, can become difficult to implement; given that all clients would have to be constantly synchronized on the state of the host, then delegate a host if the original was to disconnect. \\ %(?)  

In this case, delay tolerance means that a player who disconnects from the poker match will be able to reconnect at the end of the game. A new, unique player will not take their slot however, and we decided to allow the game to continue as normal, because otherwise the match could be on hold indefinitely waiting for the player to reconnect.

\subsubsection{Server}
For the server, we needed a way for each connection to be asynchronous, such that one connection which loses connectivity or experiences an error would not affect the others. There were multiple options that we could have taken to design the server, including a single-threaded approach, a thread pool and a multi-process approach. \\

To clarify, a thread is a single line of execution - that is, a sequence of instructions separate to others - that is processed on a CPU at one time. As noted by Kleiman \cite{client_server}, the rise of client-server programming and multiple processors on a CPU drove the use of threads. A process is a separate program entity, meaning that it contains its own memory separate to that of others, and can host one or more threads of execution. \\

With networking, it is typical that each connection is given its own thread. This is because networking code involves the retrieving and sending of data. The retrieval of data requires that the series of execution is halted; these functions are known as \textit{blocking calls} \cite{blocking_calls}, where the program cannot continue until data has been retrieved, hence why the connections from server must function asynchronously.  \\

This means that a single-threaded approach is not feasible because if a connection is to be severed then the rest of the players will not be able to respond due to the thread finishing execution. This would eliminate any attempt at delay-tolerance. \\

In regard to the multi-process approach, it would become cumbersome to create a new process for each connection that comes in. This is because synchronizing processes is a much more difficult task than synchronizing between threads. Whilst inter-process communication offers shared memory \citep{shared_memory} to combat the synchronization problem, it would be cumbersome to have to communicate with all processes from the server process.\\
\newpage
Figure 6 illustrates the approaches we tried in greater detail. Fig 6(a) was notoriously complex to implement, as this involved having to create a socket not just for the client and process, but also from the process to the server to retrieve data. \\

\newcommand{\fh}{18em}
\begin{figure}[h]
	\makebox[\textwidth][c]{
	\begin{subfigure}[h]{0.25\paperwidth}
		\includegraphics[height=\fh]{approach_process}
		\caption{Process approach}
	\end{subfigure}	
	
	\begin{subfigure}[c]{0.35\paperwidth}
		\includegraphics[height=\fh]{approach_pool}
		\caption{Thread-pool approach}
	\end{subfigure}	
	
	\begin{subfigure}[h]{0.3\paperwidth}
	\hspace{10pt}
		\includegraphics[height=\fh]{approach_single}
		\caption{Single-threaded approach}
	\end{subfigure}	
	}
	
	\caption{Process, thread-pool and single threaded approaches illustration}
	
\end{figure}


% show process -> thread



Figure 6(c) shows the rotation of sockets between the threads, but this approach was flimsy and often if the player was to disconnect or an error occurred, the program experienced undefined behaviour and would throw a range of exceptions such as Thread.ConcurrentModificationExceptions, a simple SocketException or simply react in an unpredictable manner. \\

Whilst these are expected when working with networking and threads, the variation of exceptions thrown meant we could not rely on a single exception which we know is the cause of an unexpected or sudden disconnection. For example, in our final implementation we only rely on a SocketException - that typically is a broken pipe - in the network I/O functions. \\

We found that Figure 6(b), a thread pool, was the best design for implementing delay tolerance. This is primarily because we are able to give each player their own thread for connectivity rather than have to add in layers of complexity to communicate between processes, or the volatile nature of single-threaded, multiple-clients approach. If a player is to lose connection, their thread in the pool will finish execution, marked as 'inactive' and can simply be skipped over, as the figure shows. 


\newpage
\subsubsection{Client}

The client is written in Java for compatibility with the server counterpart, as they will transfer Java objects. However, it was designed such that it is not a mobile application itself but rather an interface for the application to use. This was because during development, it made unit testing the client much easier as it was ran locally on the machine. Beyond this, the author's home network was restricted, meaning that running the client and server on the same machine meant they could connect, and multiple instances of the client could be run. \\

The clients on their first launch create an identity file that is unique to them, through the generation of a random number. This identity file is used when connecting to the server as a way of determining if the player has joined before and gives the opportunity to block or prevent certain players from joining. However, it primarily is used to allow players whom have had a dropout and may have disconnected from the game to join back. In any case, certain identification of a connecting client can be used in many ways; verification, management of users, etc. 

\subsubsection{Communication} %(?)
%In order to achieve a delay-tolerant network, the architecture of communication is a major factor in it being successful. What is meant by communication is that the order of sending and receiving messages from players is structured in such a way that if one was to disconnect, the server/network would not stop the game indefinitely if a player disconnected either purposefully or accidentally and the server would not unexpectedly crash when a network socket is broken. \\

In order to achieve a delay-tolerant network, the architecture of communication is a major factor in it being successful. For example, when a player is to disconnect there is a mechanism of “caching” or storing updates to send when a player reconnects. In our case, the data between initial disconnection and reconnection is not of importance, so we are able to send the current state of the game. \\


% ip https://tools.ietf.org/html/rfc791#page-7
% tcp https://tools.ietf.org/html/rfc793#page-4

Communication between the client and server should utilize the Transmission Control Protocol (TCP). 
TCP is a protocol that sits atop of the network layer of the internet. 

TCP uses the Internet Protocol (IP)\cite{ip} to route data packets, but it describes the \textit{format} of the datagrams. Furthermore, this architecture includes the use of the packets sequence number and a checksum to valid the data has not been corrupted. This is to ensure reliability \cite{tcp}, whereby the recipient must respond with an acknowledgement (ACK) packet to let the sender know they have received it. If no acknowledgement is received, the missed packet is resent.\\

In the case that our player is experiencing an unstable connection, there is the possibility packet loss will occur. TCP negates the affects of packet loss, namely by ensuring data integrity is kept.


In order to communicate with each client effectively, we needed to abstract the way that we handle connections. As previously mentioned, the architecture is important as an unexpected disconnection can cause a wide range of errors depending on the state of the current program. \\ %(?) 

This became evident during development when we kept object I/O streams within the TPokerThread class. Accessing these streams generated undefined behaviour when the player had lost connection. Whilst we have a thread pool to keep connections alive, we needed a method of flagging that a user has folded but not disconnected or vice versa, and a way to communicate certain procedures to them. In this case, an aptly-named class \textit{Player} was created. \\

The Player class is handled and only used by the server, as it is the counter-part to the TPokerClient, which runs on a separate computer or device. It provides the server with necessary information such as where to write objects to or read them from, the ID of the player in order of creation and the players identity file, which acts as an authorization key, and the TPokerThread that it represents in the thread-pool. 

\newpage

%can talk about synchronizing creation of both client and server obj steams

\subsection{User Interface}

The user interface is a simple command-line interface, whereby the player is able to view their cards and the total cards in play on the table, as well as the round. They are able to input their actions such as call, raise, fold or view their own chips. \\

Whilst this interface may seem quite limited, the underlying interface allows the UI to be transferred to other mediums, such as a mobile application. This is because the client reads in objects and formats them as text, and sends their actions back as a string; implementing a mobile application would simply require catching the objects and formatting them in a respective manner. Similarly, the new application would only have to send back the players actions as strings.


\begin{figure}[h]
\begin{center}
\includegraphics[width=300pt]{ui}
\end{center}
\caption{User interface}
\end{figure}

\newpage


\subsection{Algorithms}
\subsubsection{Evaluating Hand Strength}
Evaluating a hand's strength is rather difficult and can be approached many ways. In our case, we opted to use a more human readable format by writing many helper functions that delegate certain checks for each type of hand, i.e. isStraight, isRoyalFlush, etc. This has the benefit of being readable and somewhat more unit testable; the only problem is that the speed of the algorithm can be quite slow, compared to other methods such as lookup tables have existed for some time. \cite{lookup} \\ % \hyperlink{lookup}{(L. Teofilo, 2013)}.

Whilst we knew using a computational approach like this would be slower, we attempted to bring down the speed of the algorithm by processing commonly accessed attributes ahead of time.\\

\setlength{\fboxrule}{0pt}
\noindent\fbox{%

\begin{minipage}[t]{\linewidth}
\begin{center}
\nineclubs \kingclubs \ \ \ \ \fiveclubs \sixclubs \sevenhearts \kingclubs \ninediamonds
\end{center}
\begin{center}
Two cards from the player, five from the flop, turn and river
\end{center}
\end{minipage}}%

\vspace{8pt}
From this array of unordered cards, we can use a TreeMap to store their faces (values) and suits which: 
\begin{enumerate}
	\item Does not accept duplicate entries
	\item Orders its entries by key automatically
	\item Provides an easy method of counting its entries
\end{enumerate}

\vspace{8pt}

This means that our cards are already sorted from most powerful to lowest in terms of value as they are entered into the TreeMap. This means we can easily check if a flush exists by accessing the first value of the map - which will be accessed in a time of O(1) - and checking if it has a value of 5 or more. Similarly, if we need to check if any three/four-of-a-kind or pairs exists, we can iterate through the map and we will have the most powerful hand if one exists. 

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{treemaps} \\
\caption{Diagram showing the ordering of key-values in TreeMaps}
\end{center}
\end{figure}





\newpage


\subsubsection{Reconnecting a player}

When a player's connection is disrupted, the network socket will break and cause attempts to send data or retrieve data from the player to throw a SocketException. This is how we detect if a client has experienced a disruption, as intentional disconnection from the match is done via a DISCONNECT message. \\

As previously discussed, the player object holds data separate from the connection. Therefore, when a player disconnects the server will perform the following: \\

\hypertarget{algorithm_identity}{}
\SetKwInOut{Parameter}{Parameters}
\SetKwData{KwDat}{\textbf{Variable}}
\begin{algorithm}[H]
\SetAlgoLined
\KwResult{Player is reconnected or match continues without}
 \Parameter{Player object} 
  \texttt{\\}
 
 \KwDat{ServerSocket}: The host socket responsible for receiving connections \\
 \KwDat{ReconnectionTimeout}: 15000 (15 seconds) \\
 \KwDat{Thread}: Players connection thread \\
 \KwDat{ThreadPool}: Pool hosting worker threads \\
 
 \texttt{\\}
 ServerSocket.\textit{Timeout} = ReconnectionTimeout\;
 Thread.\textit{KEEP\_ALIVE} = false\;
 \texttt{\\}
 
 \eIf{ThreadPool.remove(Thread) is True}{
 	 /* Wait until we have received a new connection or timeout */ \\
	 \KwDat{NewSocket} = ServerSocket.accept()\;
	 \If{NewSocket is not set}{
     	/* Player has not reconnected in time; remove from match */ \\
	    Player.\textit{disconnected} = true\;
	    Player.\textit{folded} = true\;
	 }
  }{
  	/* There was an error removing the thread */ \\
  	Handle error appropriately; the pool itself may be non-functional
  }
  
  /* Here, we now revitalize or renew the player contents */

  Player.\textit{socket} = NewSocket\;
  Player.\textit{objectOut} = ObjectOutputStream(NewSocket)\;
  Player.\textit{objectIn} = ObjectInputStream(NewSocket)\;
  Player.\textit{thread} = Thread(NewSocket)\;
  
  \texttt{\\}
  
  \KwDat{ConnIdentity}: The connecting client's identity \\
  \eIf{ConnIdentity is the same as disconnected Players}{
  	Send game state to this new player \\
  	Add player's new thread to pool\\
  	Continue with match
  } {
  	Reject this player and restart algorithm, waiting for new connection
  }
  
 \caption{Reconnecting a player}
 
\end{algorithm}

\newpage



%\subsubsection{Evaluating Win Condition}
%Win evaluation can be done by sorting each players hand by result, i.e. Royal Flush, Four of Kind, Straight. If each player has a unique result, then we can simply take the top result, in this case Royal Flush. If two players contest the highest result, e.g. a Straight, then we'll look at the highest card in the TResult object, which determines each players result (i.e. Three of a Kind) and the highest card. \\
%
%If two players contest the highest result, but have the same highest card, then the pot is split as is the normal result in poker. 
%
%\subsubsection{Determining a Straight}
%Determining whether a hand is a straight would be difficult had we not assigned values to the Face values of our cards. Take the following table, whereby the first two cards are the players, the other 5 are on the table. \\
%
%\begin{center}
%\tendiamonds \twoclubs \ \ \ \ \ \ \  \eightclubs \ninehearts \sixdiamonds \fiveclubs \sevenspades
%\end{center}
%
%This hand's highest rank would be a straight, as we 10 - 5 in the hand; though they are not displayed as in order. \\
%
%Take for example we start off with the first card, 10 of Diamonds. We would have to find any card on the table that is either a Jack or a 9. From here, we would then have to branch off and see if there is a card that is a Queen or an Eight, for either direction. This would have to be done for each card on the table, and optimizations would make the code more complex and introduce more areas where bugs or incorrect results can slip in.\\
%
%However, since we have assigned each of the Faces values as seen previously,  we can use Java's Collections library to sort our cards from highest to lowest. This way, we only need to search in one direction, i.e. if the next card is lower than our current one; which is shown in Appendix 7.4. This will reduce code complexity and also the worst case scenario; we don't have to arbitrarily search the entire deck for an 'adjacent' number.



\newpage
\section{Implementation}

\subsection{Project Requirements}
Our requirements for the project were not particularly specific, however some core ones were defined in our vision and scope, as well as project proposal. 

\subsubsection{Backend}
\textbf{Functional}
\begin{itemize}
	\item Written in Java / Kotlin
	\item Able to generate a result (i.e. 3 of kind) from the players hand and table
	\item Abstracts elements of card-based games (i.e. hands, cards, faces, suits)
\end{itemize}
%\textbf{Non-Functional}
%\begin{itemize}
%	\item Unit-testable	
%	\item Small, portable 
%\end{itemize}

\subsubsection{Server}
\textbf{Functional}
\begin{itemize}
	\item Runs on Linux and Windows
	\item Handles the evaluation of games internally
	\item Utilizes TCP/IP
\end{itemize}

\textbf{Non-Functional}
\begin{itemize}
	\item Open-sourced
	\item Available for free download
\end{itemize}

\subsubsection{Application}

\textbf{Functional}
\begin{itemize}
	\item Ability to run on any JVM-compatible device
	\item Allows for connecting to servers via IP address
\end{itemize}

\textbf{Non-Functional}
\begin{itemize}
	\item Presents a simple, uncluttered interface for connecting/joining games
	\item Presents a simple game screen, with not too much clutter for game statistics
	\item Presents the users current chips for online matches
	\item Presents the users current chips within the game
	\item Presents a server browser for online matches
\end{itemize}

\newpage



\subsection{Client}
\subsubsection{Development}

During development, we had to make multiple changes to the initial design of the client. Initially, we planned to make it solely an Android application, as this would provide a good opportunity to showcase drop outs. However, developing it as only an Android application made testing much more difficult. It was for this reason we opted to make it a terminal-based application that could be hooked into an application later on. \\

Because we made this choice, the ability to instantly get a client/server connection running on the development machine was trivial, as a modern computer is able to do this very quickly compared to having to compile an Android application and run it either on an emulator or even slower on a physical device, let alone having to develop a build system to compile both the server and an Android application. \\

Furthermore, we realised that the client would need some form of identification, because we didn't want players whom hadn't been in the game to join back; this would annoy users of the system if they were to experience a drop out and could not reconnect, as seen in \hyperlink{algorithm_identity}{Algorithm 1}. Therefore, we opted to make a file that exists locally to identify the user and is created upon first launching the program. \\

We arrived at this choice because the other approaches were not the most reliable or optimal. For example, we could have used the IP address of the user to identify them but using an IP address is extremely unreliable as they are very susceptible to change - especially after a drop out from the clients internet provider. We could have also used a media-access control (MAC) address to identify them - which is tied to the devices network interface card (NIC) - but this is quite difficult to retrieve from a Java perspective, some devices may or may not return one reliably. \\

Therefore, we decided that the most reliable option would be to use an approach that can be used on any device - be it a web browser, a mobile device or a desktop, and that would be using a file to identify the user. While many devices may not support some network functions, it is guaranteed that a file can be created and read anywhere Java is used. 

\newpage
\subsection{Server}
\subsubsection{Overview}
As the target of delay tolerance implies, the server was a crucial part of the project. It also however took a lot of effort to coordinate with the client, as any changes made to the client would need to be synchronized with the server, and so development of both had to be done somewhat in parallel. \\

We had multiple challenges to overcome when developing the server, including: \\

\begin{itemize}
	\item Allowing multiple clients to connect
	\item Gracefully deal with disconnections
	\item Allow only those who'd previously lost connection back
	\item Find a suitable method for hosting the server
\end{itemize}


\subsubsection{Development}
The server is written in Java as this means we can use compatible, standard Java networking libraries to communicate with the client counterpart. Furthermore, this makes it simple to port to new platforms to host on, particularly any operating system with a Java Virtual Machine. \\

This platform interoperability particularly came in useful when we needed to test external devices being able to connect and thus the delay tolerance of the network, as local hosted servers are typically hard to simulate delay or drop outs. We ran into the problem of restrictive network policies at student accommodation not allowing us to host the server so that we could attempt to connect from the internet, and as such we had to find another place to host the server to test delay and unexpected drop outs. \\

As we were able to simply compile the server and its dependencies into a JAR file, we decided to host an Amazon Web Services (AWS) EC2 instance - a small, Amazon-hosted Linux server - to test connections that originated over the internet. From here, we could simply push the file onto the server, configure the firewall to open a specified port, and test. \\

The server itself uses a thread pool to keep connections to clients alive, whereby each connection has its own thread and thus sequence of execution as previously discussed. A thread pool simply provides a way for each thread to get its time to execute \cite{threadpool}. \\ 

% \hyperlink{threadpool}{(Oracle, 2019)}. \\

\newpage

Furthermore, we wrap these threads in a Player class, which not only keeps a reference to the connection thread in the pool, but also the data regarding the player: their identity, chip count, fold status and connectivity information; whether they have disconnected intentionally or a network error occurred, and their cards. These are then stored in an array, which solve a problem we encountered with our original design.

\begin{figure}[h]

	\makebox[\textwidth][c]{
	\begin{subfigure}[h]{0.6\textwidth}
		\includegraphics[width=\textwidth]{server_workings_old}
		\caption{Initial}
	\end{subfigure}	
	
	\begin{subfigure}[h]{0.6\textwidth}
		\includegraphics[width=\textwidth]{server_workings_new}
		\caption{Final}
	\end{subfigure}	
	}
	
	\caption{Synchronization of player data and threads: initial versus final design}
\end{figure}

The flaw within Figure 9(a) is that we looked to store data in a database and initially kept some of this data within the threads themselves. However, upon disconnection during the round or before the ability to save to the database, the thread will finish execution and be destroyed; losing all of the players data. \\

We found the best method was to keep the thread independent of the data. The player class creates a new connection thread for the player, and passes it to the thread pool to be executed on first connection. In the case that the player loses connectivity, the thread will finish execution and be removed from the pool but the player's data remains in the object. \\

When the disconnected player rejoins, their identity is checked against those whom have disconnected: if they are rejoining, the thread within the player object can simply be 'swapped' out with a new instance and all network input/output can be regenerated. This removes the possibility of data been wiped in a drop out or significant delay, and the need for an external constantly updated database.


%% (!)
%\begin{figure}[h]
%	\makebox[\textwidth][c]{
%	\begin{subfigure}[h]{0.6\textwidth}
%		\includegraphics[width=\textwidth]{demo_server}
%		\caption{Server receiving data from clients}
%	\end{subfigure}	
%	
%	\begin{subfigure}[h]{0.6\textwidth}
%		\includegraphics[width=\textwidth]{demo_client}
%		\caption{Client showing received enums and card, sending commands}
%	\end{subfigure}	
%	}
%	
%	\caption{Demonstration of bidirectional server-client communication}
%	
%\end{figure}


\newpage

\subsection{Data Classes}


%(?) JSON/XML
\subsubsection{Overview}
The data classes used in the project include cards comprised of faces and values, ranks including different outcomes of hands and more. When considering how we were going to design them, we needed to look at how they would be sent between the client and server, including using a object representation format such as JSON, XML or a built-in method.

We decided on using the built-in Serializable interface and the Object(Input/Output)Streams, as this did not require the need to built a serializer and deserializer for each object that we wanted to move over the network. Instead, we could build classes from enumerated and primitive (i.e. integers, strings) and then Java would serialize them for us. This does however have the impact that the server and client programs must have data classes built from the same source, otherwise there will be a version mismatch.

% show dataoutputstream/inputstream

\subsubsection{Face / Suit}
For the Face and Suit part of the Card class (Queen, King, Ace, etc) it was best to use an enumerated (enum) type. This is because we can easily initialize \& create them, both initially on creation of pulling a new Card, but they are inherently much easier to transfer over a network due to the default and final values associated with them. \\

This was chosen because it simplifies reading the code, but they can also easily define other values in their constructor. Enums can easily be transferred over a network via their value name or id. The code following shows this, as we can set a custom display value, e.g. "Three" and a value for the card. Later on, we can use these values to sort hands and make determining straights and other results much easier. 

\begin{lstlisting}*[language=java,firstnumber=0]
public enum Face {

	// these can be accessed as Face.TWO, Face.ACE, etc. 
    TWO   ("Two", 0),
    THREE ("Three", 1),
    FOUR  ("Four", 2),
    FIVE  ("Five", 3),
	...
    JACK  ("Jack", 9),
    QUEEN ("Queen", 10),
    KING  ("King", 11),
    ACE   ("Ace", 12);

    private final int val;
    private final String str;

    Face(String display, int value) {
        this.str = display;
        this.val = value;
    }
}
\end{lstlisting}


Because the Card class - which will be transferred over the network most frequently - is built from enumerated classes, sending a Card class itself can easily be done by implementing Java's serializable interface. This reduced the amount of code necessary for the server-client architecture.

\newpage

\subsection{Build System}
During our development we initially planned to just use the built-in IntelliJ integrated development environments (IDE) build functionality. However, we realised that the project requirements required that we open-sourced the code so that people could build upon it and make their own projects. \\

Therefore, we needed a build system that was reliable and would work on any system compatible with Java and the build system, as an IDE build configuration can be dependent on ones computer and preferences. This is where we decided to use Gradle as a build system. \\

Gradle \citep{gradle} is a flexible, cross-platform build system with the ability to not only compile code but include test-case checks before completion. It is feature-rich, with the ability to add dependencies/libraries from common repositories such as Maven\citep{maven}. It also provides the ability for plug-ins, enabling further automation for the likes of transferring files to a server, and is the preferred build system for Android. \cite{android_gradle} \\

Gradle provided solutions and time-saving measures that we did not anticipate during the beginning of the project. As we previously discussed in implementing the client, we needed an identity file for each client so that we could identify them. During development, we used a JAR of the client which would create its own identity file in the folder it was located, and so we used a file structure which contained players 1 - 8. 


\begin{figure}[h]
\begin{lstlisting}[frame=single,framexleftmargin=10pt, framexrightmargin=15pt]
// define the JAR's location 
def jarToCopy = copySpec { from 'build/libs/texas-client-' + version + '.jar' }

// for each player (p0 - 8) folder, copy the JAR above to the players folder
task moveToEnv {
    ['env/p1/', 'env/p2/', 'env/p3/', 'env/p4/', 
     'env/p5/', 'env/p6/', 'env/p7/', 'env/p8/'].each { dest ->
        copy { with jarToCopy into dest }
    }
}
\end{lstlisting}
\caption{Copying the client JAR to 'virtual' player folders}
\end{figure}

We realised that the server would need to be in a JAR format so that we were able to distribute the software; we found that with Gradle, it is possible to jar a certain class and its dependencies for use elsewhere, as shown below. This method also applies to the client JAR as referred to in Figure 10.
\begin{figure}[h]
\begin{lstlisting}[frame=single,framexleftmargin=10pt, framexrightmargin=15pt]
task servJar(type: Jar) {
    manifest {
        attributes 	'Implementation-Title': 'TPoker Server',
					'Main-Class': 'com.scully.server.ServerLauncher'
    }
    baseName = project.name + '-server'
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}
\end{lstlisting}
\caption{Compiling the server package to a JAR file}
\end{figure}
\newpage
As we will discuss later in the evaluation section, we required that the server is hosted elsewhere than the client's device, to test delay and disconnect tolerance properly in a more suitable environment. Unbeknownst to us, we found a Gradle plugin that supports us using Secure Shell (SSH) to move certain files to a remote server. \\
\begin{figure}[h]
\begin{lstlisting}[frame=single,framexleftmargin=10pt, framexrightmargin=15pt]
remotes {
    withGroovyBuilder {
        "create"("webServer") {
            setProperty("host", "ec2-35-178-207-104.eu-west-2.compute.amazonaws.com")
            setProperty("user", "ubuntu")
            setProperty("identity", file('rekop.pem'))
        }
    }
}

FileTree myFileTree = fileTree(dir: 'build/libs/') // JAR files location

// example exec: $ ./gradlew deploy
task deploy {
    doLast {
        ssh.run {
            session(remotes.webServer) {
					// move JAR files to server
                	put from: myFileTree.asList(), into: '/home/ubuntu/' 
                	// restart remote server; grab server output
                	execute '~/restart_server.sh' 
            }
        }
    }
}
\end{lstlisting}
\caption{Declaring remote server address/credentials, transferring files and restarting}
\end{figure}

\newpage
This further saved time, because the workflow typically went as follows: \\

\begin{enumerate}
	\item Develop a change to server/client
	\item Build from Gradle
	\item Gradle will Jar the Client and Server
	\item Gradle will push the new server JAR to the remote server
	\item Gradle will execute a script on the AWS server to restart the server
	\item Gradle will grab the terminal output of the server \\
\end{enumerate}

Note that these can all be executed in sequence, so that we could execute a Gradle build script, and it would run the tests, ensure non are failing, build the necessary components, push them to the remote server, get that servers output (so we can see connections and what the server is doing) and then connect. 

This was possibly the most insightful part of the project, as the power of time-consuming or complicated set up can make development and testing a breeze; on a custom Arch Linux install, we were able to launch multiple terminals spawning multiple clients, as shown below. \\

\begin{figure}[h]
\begin{lstlisting}[language=bash,frame=single]

ROOT_DIR=$HOME/Dissertation/texas/env # root directory to search in
T_SWITCHES="-e" # switches for terminal, -e = execute command
JAVA_EXEC="java -jar" # command to run
CLIENT_JAR_NAME="texas-client-1.2.1.jar" # file to launch with above
HOST="ec2-35-178-207-104.eu-west-2.compute.amazonaws.com" # server address

# for p1-p8 in ROOT_DIR (env/), -
for PLYR_DIR in $(ls $ROOT_DIR)
do
	# $TERMINAL = default terminal used
	# example cmd: alacritty -e java -jar env/p0/texas-client-1.2.1.jar 192.168.0.1
	$TERMINAL $T_SWITCHES $JAVA_EXEC $ROOT_DIR/$PLYR_DIR/$CLIENT_JAR_NAME $HOST
done

# on commandline: setting exec perms (one-time necessary) + run script
$ chmod +x script.sh
$ ./script.sh
\end{lstlisting}
\caption{The Bash script used to launch multiple instances of the client to a server for testing}
\end{figure}


\newpage
\section{Evaluation}
\subsection{Unit Testing}
Unit testing was crucial in the development of the back end, as writing and designing algorithms for this ahead of time is quite difficult due to the amount of edge cases that can crop up when there are many outcomes of a poker hand. \\

\begin{figure}[h]
\begin{center}
	\includegraphics[width=0.75\textwidth]{tests}
		\caption{Unit test results}
\end{center}
\end{figure}

It also showed how testing can not just be used to verify that a program is working properly, but to drive its development forward. This constant feedback of cases that needed to be tested helped spot bugs and allowed each part of the evaluator to work together flawlessly. Because most edge cases had been ironed out in isFlush and isStraight functions, implementing whether or not a hand was a straight flush was a somewhat simple procedure. \\

Furthermore tests that would have been somewhat cumbersome to perform were suddenly much easier to; the Deck that we use to pull cards contains, as normal, 52 cards in an array. We needed to test that no two cards came out the same, and that pulling 52 cards resulted in an error being thrown. \\

\newpage
\subsection{Testing network code}
Testing network code is much more different than testing typical single-threaded, local code. Due to the blocking nature of network calls when we hosted the server and client on the same computer, it became with a debugger to root down the cause of the issues as we didn't always know what the client or server was waiting for. \\

Whilst it is possible to unit-test network code, it can be tedious and complex to set-up, and not all errors can easily be detected. We opted to use a logging system, whereby we constantly printed what was being sent on both sides of the network to the console to see if there was delay, a block of execution or simply crashed. We found this to be the most effective way, as debuggers were often awkward to use when working with multiple threads and when a bug was unpredictable.\\

Figure 15 shows the server and client logs side by side. For example, when we are sending card information we know that if the client is to crash or otherwise encounter an error, then the client is attempting to cast the sent data to the wrong type, i.e. the client is expecting the data to be a PlayerInfo, instead of Card data.

\vspace{12pt}
\begin{figure}[h]

	\makebox[\textwidth][c]{
	\begin{subfigure}[h]{0.6\textwidth}
		\includegraphics[width=\textwidth]{server_log}
		\caption{Server}
	\end{subfigure}	
	
	\begin{subfigure}[h]{0.6\textwidth}
 		\includegraphics[width=\textwidth]{client_log}
		\caption{Client (Player 0)}
	\end{subfigure}	
	}
	
	\caption{Output of both the server and client in synchronization}
\end{figure}


\newpage
\section{Summary and Reflections}
\subsection{Management}
To help me manage what needs to be done in the project and primarily drive development, GitLab issues tracker have been made for various tasks that need to be completed. These are easy to read via the use of labels and offer reminders through email. In addition to this, branches are created for each issue to manage changes to code. \\

In the initial design stages, I focused on the vision and scope whereby outlining the ideal product but also the bare essentials for the project. Working under agile principles, I focused on getting a usable algorithm for evaluating poker hands as this gives us early ideas from where to go next or problems that would arise; once we had this to a good state, research for how the server will handle sending these objects or communicating became easier.  \\

\hyperlink{app_gantt}{Appendix 8.1} shows the Gantt chart followed throughout the project. There were some issues which took much longer than anticipated, namely issues with networking as we couldn't easily "test" our way through bugs, though the poker evaluation algorithm took much less time due to it. I think that time could have been managed a bit better in regards to the server work if the network interface was planned ahead of time.

\subsection{Contributions and Reflections}

\subsubsection{Build system}
Whilst not directly related to the project at hand, I believe that the build system was a massive help and achievement in its own right in driving development forward; it has shown that it is often overlooked in terms of its power and ability to save time. \\

It would be estimated that for each change, to manually move the server JAR file to the remote server would take a minute or two and then to get multiple clients connected would take another. For each small change, this can add up to a lot of time wasted during setup; the addition of Gradle scripts made it almost instantaneous as to the setup and allowed us to rapidly test the network.

\subsubsection{Data classes}
An area that could have been improved would have been the data classes. Whilst the built-in option of packing and unpacking data, if we needed to make a small change to a data class even so much so as a tiny change in calculating something, we would have to recompile and deploy the server / client executables again. If we had taken the time to write our own packing/unpacking classes for the classes, we could have removed this limitation and sped up development further. 

\newpage

\subsection{COVID-19 Impact}
COVID-19 has not particularly disrupted development, however it has made it difficult to test the project in reality. For example, to test delay we could have used a laptop with a mobile phone connection to connect to the AWS server which would be much easier than using a stable, wired connection. Alas, due to social-distancing and lockdown guidelines we were unable to test in this environment. \\

Furthermore the ability to visit the campus to attend lectures and labs would have helped, as it would be easier to visit the supervisor for guidance on the project especially in person. This would have helped a lot more as in person demonstrations are typically much more interactive; discussions are much easier to hold with the ability to show the project in person.


\subsection{Conclusion}

Overall, I'm quite satisfied with the personal gains made from this project, as I've learned much about not only creating a network and implementing tolerance but the development of a project overall. Prior to this undertaking I hadn't much work regarding networking or concurrency as a topic, which requires a different shift in thinking compared to sequential programming like most projects. \\

I think some areas could have been improved, namely implementing a suitable and fun user interface or front-end so that it could be presented to actual players but the framework to do so is somewhat there itself and could be picked up by anyone in the future. Moreover I think time management could have gone a lot better on this project, but the demands of other project-based modules on the course limited my undivided attention on this; there was a lot of context switching involved when transferring from one module back to this project.  \\

I also think that more work could have been done on the network side to make it more robust, potentially adding in a 'lander' thread, where we continuously are looking for incoming connections, or configuration options and a method of reliably detecting that the user has disconnected rather than using a certain Java exception type to detect what has happened; which is quite flimsy. 




%A key goal of all software is that it must be efficient - both in terms of code complexity and performance. Upon undertaking this project it was naively assumed that, given how easy it is to recognize the outcome of a poker round in reality, it wouldn't be too difficult to implement efficiently through code. \\
%
%It is therefore that the algorithm currently used is very compartmentalized, and potentially slower than some implementations (such as look-up tables or doing bit-wise operations). For example, it takes between 50 - 100ms for one result to be calculated on a desktop computer. Since most servers will be running on one, it doesn't particularly matter about the performance as much as the other aspects of the program.\\
%
%\newpage
%
%Reflecting upon how I assumed Test-Driven Development would take much of our time before and during up and that we did not have "too much time to write tests and develop a fully-functional program", this proved to be false. Having instant feedback on whether it passed, what the result was and the ability to debug into it was essential. \\
%
%
%Although, initially I was under the assumption that each test case was going to have to be made up of newly created objects. Test cases wrote this way were lengthy and becoming a nuisance to write. Instead, I created a factory-esque pattern within the evaluator class itself to resolve, for example, "0D 0D 2D KD AD QD JD" into a testable hand of cards.  \\
%
%The example below shows how writing test cases becomes much easier through this method, rather than creating a new object for each test case.
%
%\begin{minipage}{.5\textwidth}
%
%\begin{lstlisting}
%TexasHand FLUSH_FOK = new TexasHand(
%    new Card(Suit.CLUBS, Face.FOUR),
%    new Card(Suit.CLUBS, Face.FOUR),
%    new Card(Suit.CLUBS, Face.FOUR),
%    new Card(Suit.CLUBS, Face.FOUR),
%    new Card(Suit.CLUBS, Face.ACE)
%);
%...
%public void isFlush() {
%    assertTrue(FLUSH_FOK.isFlush());
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{.5\textwidth}
%
%\begin{lstlisting}[breaklines=true]
%assertTrue(new TexasEvaluator("4C 4C 4C 4C AC QS JC").isFlush());
%\end{lstlisting}
%\end{minipage} \\

%\section*{Conclusion}



% Currently, I am satisfied with the backend of the project as the main area of concern for this area was accuracy in determining the outcome of a game. The use of unit tests has taught me how to effectively break a problem down into small, testable blocks of code and then re-construct them into an algorithm. \\


% However, I think that one area to work on would be time management and consequently gauging how much time tasks will take and overlooking key parts of this project; in particular the next step which is the server. This next step is not so easy to debug as it is not as easy as sequencing certain blocks of code together to create a system and most certainly not easy to debug. Therefore, I have pushed these tasks to the front of jobs to be done and allowed myself more time for these, as seen in the Gantt charts in the Appendix.

\newpage

\section{Appendix}

%\subsection{Old Gantt Chart}
%\includegraphics[width=\textwidth]{gantt_chart}

%\newpage

\subsection{Gantt Chart}

\hypertarget{app_gantt}{}
Color Key: \\
Green - Completed \\
Red - Cancelled \\

\includegraphics[width=\textwidth]{final_gantt}

\newpage
\subsection{Poker Evaluation Algorithm}
\hypertarget{app_eval}{}
\begin{lstlisting}*[language=java,numbers=none]
    public TResult evaluate() {
        // these conditions must be done in sequence, for order of rankings
        TResult kindOutput = getKinds();
        // this is required so that StraightFlushFlag is set
        TResult isStraight = isStraight();
        // variable to hold each test
        TResult result = null;
        // assignment in if statement is to remove calling method twice
        if( (result = isRoyalFlush()) != null)
            return result;

        if(StraightFlushFlag)
            return isStraight;

        // because kindOutput may be null, we need to ignore it to get past to straight
        try {
            if(kindOutput.rank == Rank.FOUR_OF_KIND)
                return kindOutput;
            if(kindOutput.rank == Rank.FULL_HOUSE)
                return kindOutput;
        } catch (NullPointerException ignored) { }

        if( (result = isFlush()) != null)
            return result;
        if(isStraight != null)
            return isStraight;
       
        if(kindOutput != null)
            return kindOutput;
        // the highest card will always be first as we use a sorted collection
        return new TResult(cards.get(0).face, Rank.HIGH_CARD);
    }
\end{lstlisting}


\newpage
\section{Bibliography}
\renewcommand\refname{}
\begin{thebibliography}{9}
% https://people.eecs.ku.edu/~saiedian/Teaching/Sp19/811/Papers/Agility/does-agile-work.pdf#s0055
\bibitem{agile_success}
\hypertarget{agile_success}{}
\begin{flushleft}
	Pedro Serrador, Jeffrey K. Pinto \\
	\textit{Does Agile work?—A quantitative analysis of agileproject success} \\
	Source in paragraph: \textit{4. Results} \\
	Retrieved from \url{https://people.eecs.ku.edu/~saiedian/Teaching/Sp19/811/Papers/Agility/does-agile-work.pdf#s0055}
\end{flushleft}


\bibitem{lookup}
\begin{flushleft}
\hypertarget{lookup}{}
	Luís Filipe Teófilo, Luís Paulo Reis, Henrique Lopes Cardoso \\
	\textit{Speeding-Up Poker Game Abstraction Computation: Average Rank Strength} \\
	Source in paragraph: \textit{2. Background} \\
	Retrieved from \url{https://www.aaai.org/ocs/index.php/WS/AAAIW13/paper/view/7083/6489}
\end{flushleft}

% https://www.cs.cmu.edu/~sandholm/texas_demo.aamas-06.pdf 2.1 Texas Hold'em
\bibitem{research_texas}
\begin{flushleft}
\hypertarget{research_texas}{}
	Andrew Gilpin, Tuomas Sandholm \\
	\textit{A Texas Hold’em poker player based on automated abstraction and real-time equilibrium computation} \\
	Source in paragraph: \textit{2.1 Texas Hold'em} \\
	Retrieved from \url{https://www.cs.cmu.edu/~sandholm/texas_demo.aamas-06.pdf}
\end{flushleft}


% https://www.wsop.com/tournaments/updates/?aid=4&grid=1628&tid=17580&dayof=8298&rr=5
\bibitem{wsop_texas}
\hypertarget{wsop_texas}{}
\begin{flushleft}
	World Series of Poker \\
	\textit{Champion Wins Main Event No-Limit Hold'em} \\
	Source in paragraph (uses Texas Hold'em terminology): \textit{Claas Segebrecht Eliminated in 2nd Place} \\
	Retrieved from \url{https://www.wsop.com/tournaments/updates/?aid=4&grid=1628&tid=17580&dayof=8298&rr=5}
\end{flushleft}

\bibitem{threadpool}
\hypertarget{threadpool}{}
\begin{flushleft}
	Oracle \\
	\textit{Thread Pools Documentation} \\
	Retrieved from \url{https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html}
\end{flushleft}

% https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/d_ticcmd.h
\bibitem{doom_network}
\hypertarget{doom_network}{}
\begin{flushleft}
	id Software \\
	\textit{Doom 1993 source code: data sent in a game tick} \\
	Retrieved from \url{https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/d_ticcmd.h}
\end{flushleft}

%http://www.cs.ioc.ee/yik/lib/2/Kleiman1pre.html
\bibitem{client_server}
\hypertarget{client_server}{}
\begin{flushleft}
	Steve Kleiman, Devang Shah, Bart Smaalders \\
	\textit{Programming with Threads, 1996} \\
	Retrieved from \url{http://www.cs.ioc.ee/yik/lib/2/Kleiman1pre.html}
\end{flushleft}

% http://www.math.hawaii.edu/~ramsey/Probability/PokerHands.html
\bibitem{str_uncommon}
\hypertarget{str_uncommon}{}
\begin{flushleft}
	Tom Ramsey, University of Hawaii \\
	\textit{5-Card Poker Hands} \\
	Retrieved from \url{http://www.math.hawaii.edu/~ramsey/Probability/PokerHands.html}
\end{flushleft}

% Test-driven Development: By Example
\bibitem{tdd_clean}
\begin{flushleft}
	Kent Beck \\
	\textit{Test-driven Development: By Example, pg. ix - x} \\
	Mirror located at \url{https://books.google.co.uk/books?id=CUlsAQAAQBAJ&lpg=PR7&ots=QBj-044PSZ&lr&pg=PR9#v=onepage&q}
\end{flushleft}

% https://agilemanifesto.org/principles.html
\bibitem{agile_principles}
\begin{flushleft}
	Agile Manifesto (17 authors) \\
	Retrieved from \url{https://agilemanifesto.org/principles.html}
\end{flushleft}

% https://developer.android.com/studio/releases/gradle-plugin
\bibitem{android_gradle}
\begin{flushleft}
	Google \\
	\textit{Android Developers: Default build system} \\
	Retrieved from \url{https://developer.android.com/studio/releases/gradle-plugin}
\end{flushleft}

% https://www.computer.org/csdl/magazine/ds/2006/08/o8002/13rRUy08MzY
\bibitem{goth_ieee}
\begin{flushleft}
	IEEE Distributed Systems Online, Greg Goth \\
	\textit{Delay-Tolerant Network Technologies Coming Together} \\
	 IEEE Distributed Systems Online, vol. 7, no. 8, 2006, art. no. 0608-o8002.\\
	Retrieved from \url{https://www.computer.org/csdl/magazine/ds/2006/08/o8002/13rRUy08MzY}
\end{flushleft}

%https://gradle.org/
\bibitem{gradle}
\begin{flushleft}
	Gradle \\
	\textit{Gradle Build Tool: Build Anything, Automate Everything, Deliver Faster} \\
	Retrieved from \url{https://gradle.org/}
\end{flushleft}

% https://maven.apache.org/repository/index.html
\bibitem{maven}
\begin{flushleft}
	Apache: Maven \\
	\textit{Maven Central Repository} \\
	Retrieved from \url{https://maven.apache.org/repository/index.html}
\end{flushleft}

% https://tools.ietf.org/html/rfc4838#page-5

\bibitem{ieee_storefwd}
\begin{flushleft}
	Institute of Electrical and Electronics Engineers (IEEE) \\
	\textit{RFC 4838 - Delay-Tolerant Networking Architecture} \\
	Retrieved from \url{https://tools.ietf.org/html/rfc4838#page-5}
\end{flushleft}

% https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.hala001/orgblockasyn.htm#orgblockasyn__sockpro

\bibitem{blocking_calls}
\begin{flushleft}
	IBM Knowledge Centre \\
	\textit{Client/server socket programs: Blocking, nonblocking, and asynchronous socket calls} \\
	Retrieved from \url{https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.hala001/orgblockasyn.htm#orgblockasyn__sockpro}
\end{flushleft}

% https://www.geeksforgeeks.org/inter-process-communication-ipc/
\bibitem{shared_memory}
\begin{flushleft}
	GeeksforGeeks \\
	\textit{Inter Process Communication (IPC)} \\
	Retrieved from \url{https://www.geeksforgeeks.org/inter-process-communication-ipc/}
\end{flushleft}

% ip https://tools.ietf.org/html/rfc791#page-7
% tcp tcp https://tools.ietf.org/html/rfc793#page-4

\bibitem{ip}
\begin{flushleft}
	Information Sciences Institute, University of Southern California \\
	\textit{Internet Protocol: DARPA Internet Program Protocol Specification p.7} \\
	Retrieved from \url{https://tools.ietf.org/html/rfc791}
\end{flushleft}

\bibitem{tcp}
\begin{flushleft}
	Information Sciences Institute, University of Southern California \\
	\textit{Transmission Control Protocol: DARPA Internet Program Protocol Specification p.4} \\
	Retrieved from \url{https://tools.ietf.org/html/rfc793}
\end{flushleft}

\bibitem{manet}
\begin{flushleft}
	Christian Raffelsberger, Hermann Hellwagner \\
	\textit{Combined Mobile Ad-hoc and Delay/Disruption-tolerant Routing} \\
	Retrieved from \url{http://www-itec.uni-klu.ac.at/bib/files/cr-adhocnow-authorver.pdf}
\end{flushleft}	



\end{thebibliography}







\end{document}